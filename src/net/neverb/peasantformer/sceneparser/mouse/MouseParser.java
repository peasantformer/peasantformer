//=========================================================================
//
//  This file was generated by Mouse 1.4 at 2011-10-27 15:02:45 GMT
//  from grammar
//    '/home/user/soft/java/idea/PeasantFormer/src/net/neverb/peasantformer
//    /sceneparser/mouse/MouseRules.txt'.
//
//=========================================================================

package net.neverb.peasantformer.sceneparser.mouse;

import mouse.runtime.Source;

public class MouseParser extends mouse.runtime.ParserBase
{
  final MouseParserSymantics sem;
  
  //=======================================================================
  //
  //  Initialization
  //
  //=======================================================================
  //-------------------------------------------------------------------
  //  Constructor
  //-------------------------------------------------------------------
  public MouseParser()
    {
      sem = new MouseParserSymantics();
      sem.rule = this;
      super.sem = sem;
    }
  
  //-------------------------------------------------------------------
  //  Run the parser
  //-------------------------------------------------------------------
  public boolean parse(Source src)
    {
      super.init(src);
      sem.init();
      if (Config()) return true;
      return failure();
    }
  
  //-------------------------------------------------------------------
  //  Get semantics
  //-------------------------------------------------------------------
  public MouseParserSymantics semantics()
    { return sem; }
  
  //=======================================================================
  //
  //  Parsing procedures
  //
  //=======================================================================
  //=====================================================================
  //  Config = Space Group EOT {config} ~{recover} ;
  //=====================================================================
  private boolean Config()
    {
      begin("Config");
      if (Config_0())
      { sem.config(); return accept(); }
      else sem.recover();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  Config_0 = Space Group EOT
  //-------------------------------------------------------------------
  private boolean Config_0()
    {
      begin("");
      Space();
      if (!Group()) return rejectInner();
      if (!EOT()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Group = Literal Lcurly PropertyList Rcurly {group} ;
  //=====================================================================
  private boolean Group()
    {
      begin("Group");
      if (!Literal()) return reject();
      if (!Lcurly()) return reject();
      PropertyList();
      if (!Rcurly()) return reject();
      sem.group();
      return accept();
    }
  
  //=====================================================================
  //  PropertyList = (Property / Group)* {propertylist} ;
  //=====================================================================
  private boolean PropertyList()
    {
      begin("PropertyList");
      while (PropertyList_0());
      sem.propertylist();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  PropertyList_0 = Property / Group
  //-------------------------------------------------------------------
  private boolean PropertyList_0()
    {
      begin("");
      if (Property()) return acceptInner();
      if (Group()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  Property = Literal Equals (NumberDimension / QuotedString / Point /
  //    Point2DArray / Color / IDArray) Space SemiColon {property} ;
  //=====================================================================
  private boolean Property()
    {
      begin("Property");
      if (!Literal()) return reject();
      if (!Equals()) return reject();
      if (!NumberDimension()
       && !QuotedString()
       && !Point()
       && !Point2DArray()
       && !Color()
       && !IDArray()
         ) return reject();
      Space();
      if (!SemiColon()) return reject();
      sem.property();
      return accept();
    }
  
  //=====================================================================
  //  PointNDArray = Lbracket PointNDElem (Comma PointNDElem)* Rbracket
  //    ;
  //=====================================================================
  private boolean PointNDArray()
    {
      begin("PointNDArray");
      if (!Lbracket()) return reject();
      if (!PointNDElem()) return reject();
      while (PointNDArray_0());
      if (!Rbracket()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  PointNDArray_0 = Comma PointNDElem
  //-------------------------------------------------------------------
  private boolean PointNDArray_0()
    {
      begin("");
      if (!Comma()) return rejectInner();
      if (!PointNDElem()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  PointNDElem = PointNDArray / Point ;
  //=====================================================================
  private boolean PointNDElem()
    {
      begin("PointNDElem");
      if (PointNDArray()) return accept();
      if (Point()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Point2DArray = Lbracket PointArray (Comma PointArray)* Rbracket
  //    {point2d} ;
  //=====================================================================
  private boolean Point2DArray()
    {
      begin("Point2DArray");
      if (!Lbracket()) return reject();
      if (!PointArray()) return reject();
      while (Point2DArray_0());
      if (!Rbracket()) return reject();
      sem.point2d();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Point2DArray_0 = Comma PointArray
  //-------------------------------------------------------------------
  private boolean Point2DArray_0()
    {
      begin("");
      if (!Comma()) return rejectInner();
      if (!PointArray()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  PointArray = Lbracket Point (Comma Point)* Rbracket {point1d} ;
  //=====================================================================
  private boolean PointArray()
    {
      begin("PointArray");
      if (!Lbracket()) return reject();
      if (!Point()) return reject();
      while (PointArray_0());
      if (!Rbracket()) return reject();
      sem.point1d();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  PointArray_0 = Comma Point
  //-------------------------------------------------------------------
  private boolean PointArray_0()
    {
      begin("");
      if (!Comma()) return rejectInner();
      if (!Point()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Point = Lbrace NumberDimension Comma NumberDimension Rbrace {point}
  //    ;
  //=====================================================================
  private boolean Point()
    {
      begin("Point");
      if (!Lbrace()) return reject();
      if (!NumberDimension()) return reject();
      if (!Comma()) return reject();
      if (!NumberDimension()) return reject();
      if (!Rbrace()) return reject();
      sem.point();
      return accept();
    }
  
  //=====================================================================
  //  IDArray = Lbracket ID (Comma ID)* Rbracket {idarray} ;
  //=====================================================================
  private boolean IDArray()
    {
      begin("IDArray");
      if (!Lbracket()) return reject();
      if (!ID()) return reject();
      while (IDArray_0());
      if (!Rbracket()) return reject();
      sem.idarray();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  IDArray_0 = Comma ID
  //-------------------------------------------------------------------
  private boolean IDArray_0()
    {
      begin("");
      if (!Comma()) return rejectInner();
      if (!ID()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  ID = NumberPositive Space {id} ;
  //=====================================================================
  private boolean ID()
    {
      begin("ID");
      if (!NumberPositive()) return reject();
      Space();
      sem.id();
      return accept();
    }
  
  //=====================================================================
  //  Color = "#" ColorARGB Space {color} ;
  //=====================================================================
  private boolean Color()
    {
      begin("Color");
      if (!next('#')) return reject();
      if (!ColorARGB()) return reject();
      Space();
      sem.color();
      return accept();
    }
  
  //=====================================================================
  //  ColorARGB = HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit
  //    (HexDigit HexDigit)? ;
  //=====================================================================
  private boolean ColorARGB()
    {
      begin("ColorARGB");
      if (!HexDigit()) return reject();
      if (!HexDigit()) return reject();
      if (!HexDigit()) return reject();
      if (!HexDigit()) return reject();
      if (!HexDigit()) return reject();
      if (!HexDigit()) return reject();
      ColorARGB_0();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ColorARGB_0 = HexDigit HexDigit
  //-------------------------------------------------------------------
  private boolean ColorARGB_0()
    {
      begin("");
      if (!HexDigit()) return rejectInner();
      if (!HexDigit()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Lcurly = "{" Space <{> ;
  //=====================================================================
  private boolean Lcurly()
    {
      begin("Lcurly","{");
      if (!next('{')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  Rcurly = "}" Space <}> ;
  //=====================================================================
  private boolean Rcurly()
    {
      begin("Rcurly","}");
      if (!next('}')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  Lbrace = "(" Space <(> ;
  //=====================================================================
  private boolean Lbrace()
    {
      begin("Lbrace","(");
      if (!next('(')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  Rbrace = ")" Space <)> ;
  //=====================================================================
  private boolean Rbrace()
    {
      begin("Rbrace",")");
      if (!next(')')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  Lbracket = "[" Space <[> ;
  //=====================================================================
  private boolean Lbracket()
    {
      begin("Lbracket","[");
      if (!next('[')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  Rbracket = "]" Space <]> ;
  //=====================================================================
  private boolean Rbracket()
    {
      begin("Rbracket","]");
      if (!next(']')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  Equals = "=" Space <=> ;
  //=====================================================================
  private boolean Equals()
    {
      begin("Equals","=");
      if (!next('=')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  SemiColon = ";" Space <;> ;
  //=====================================================================
  private boolean SemiColon()
    {
      begin("SemiColon",";");
      if (!next(';')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  Comma = "," Space <,> ;
  //=====================================================================
  private boolean Comma()
    {
      begin("Comma",",");
      if (!next(',')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  NumberDimension = NumberFloat [fmpr]? Space {number} ;
  //=====================================================================
  private boolean NumberDimension()
    {
      begin("NumberDimension");
      if (!NumberFloat()) return reject();
      nextIn("fmpr");
      Space();
      sem.number();
      return accept();
    }
  
  //=====================================================================
  //  NumberFloat = NumberInt ("." NumberPositive)? ;
  //=====================================================================
  private boolean NumberFloat()
    {
      begin("NumberFloat");
      if (!NumberInt()) return reject();
      NumberFloat_0();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  NumberFloat_0 = "." NumberPositive
  //-------------------------------------------------------------------
  private boolean NumberFloat_0()
    {
      begin("");
      if (!next('.')) return rejectInner();
      if (!NumberPositive()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  NumberPositive = Digit+ ;
  //=====================================================================
  private boolean NumberPositive()
    {
      begin("NumberPositive");
      if (!Digit()) return reject();
      while (Digit());
      return accept();
    }
  
  //=====================================================================
  //  NumberInt = "-"? Digit+ ;
  //=====================================================================
  private boolean NumberInt()
    {
      begin("NumberInt");
      next('-');
      if (!Digit()) return reject();
      while (Digit());
      return accept();
    }
  
  //=====================================================================
  //  QuotedString = """ UnquotedString """ Space {string} ;
  //=====================================================================
  private boolean QuotedString()
    {
      begin("QuotedString");
      if (!next('"')) return reject();
      if (!UnquotedString()) return reject();
      if (!next('"')) return reject();
      Space();
      sem.string();
      return accept();
    }
  
  //=====================================================================
  //  UnquotedString = Characters ("\"" Characters)* ;
  //=====================================================================
  private boolean UnquotedString()
    {
      begin("UnquotedString");
      if (!Characters()) return reject();
      while (UnquotedString_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  UnquotedString_0 = "\"" Characters
  //-------------------------------------------------------------------
  private boolean UnquotedString_0()
    {
      begin("");
      if (!next("\\\"")) return rejectInner();
      if (!Characters()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Characters = _*+ (&"\"" / &""") ;
  //=====================================================================
  private boolean Characters()
    {
      begin("Characters");
      while (!Characters_0())
        if (!next()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Characters_0 = &"\"" / &"""
  //-------------------------------------------------------------------
  private boolean Characters_0()
    {
      begin("");
      if (Characters_1()) return acceptInner();
      if (Characters_2()) return acceptInner();
      return rejectInner();
    }
  
  //-------------------------------------------------------------------
  //  Characters_1 = &"\""
  //-------------------------------------------------------------------
  private boolean Characters_1()
    {
      begin("","\"\\\"\"");
      if (!next("\\\"")) return rejectAnd();
      return acceptAnd();
    }
  
  //-------------------------------------------------------------------
  //  Characters_2 = &"""
  //-------------------------------------------------------------------
  private boolean Characters_2()
    {
      begin("","\"\"\"");
      if (!next('"')) return rejectAnd();
      return acceptAnd();
    }
  
  //=====================================================================
  //  Literal = LiteralFirst LiteralRest* Space ;
  //=====================================================================
  private boolean Literal()
    {
      begin("Literal");
      if (!LiteralFirst()) return reject();
      while (LiteralRest());
      Space();
      return accept();
    }
  
  //=====================================================================
  //  LiteralRest = Letter / Digit / Separators ;
  //=====================================================================
  private boolean LiteralRest()
    {
      begin("LiteralRest");
      if (Letter()) return accept();
      if (Digit()) return accept();
      if (Separators()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  LiteralFirst = Letter ;
  //=====================================================================
  private boolean LiteralFirst()
    {
      begin("LiteralFirst");
      if (!Letter()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Separators = [-_.] ;
  //=====================================================================
  private boolean Separators()
    {
      begin("Separators");
      if (!nextIn("-_.")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Digit = [0-9] ;
  //=====================================================================
  private boolean Digit()
    {
      begin("Digit");
      if (!nextIn('0','9')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  HexDigit = [0-9] / [a-f] / [A-F] ;
  //=====================================================================
  private boolean HexDigit()
    {
      begin("HexDigit");
      if (nextIn('0','9')) return accept();
      if (nextIn('a','f')) return accept();
      if (nextIn('A','F')) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Letter = [a-z] / [A-Z] ;
  //=====================================================================
  private boolean Letter()
    {
      begin("Letter");
      if (nextIn('a','z')) return accept();
      if (nextIn('A','Z')) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Space = (Blank / Comment / BlockComment)* ;
  //=====================================================================
  private boolean Space()
    {
      begin("Space");
      while (Space_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Space_0 = Blank / Comment / BlockComment
  //-------------------------------------------------------------------
  private boolean Space_0()
    {
      begin("");
      if (Blank()) return acceptInner();
      if (Comment()) return acceptInner();
      if (BlockComment()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  Blank = [ \r\n\t] <Blank Character> ;
  //=====================================================================
  private boolean Blank()
    {
      begin("Blank","Blank Character");
      if (!nextIn(" \r\n\t")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Comment = "//" _++ EOL <Comment> ;
  //=====================================================================
  private boolean Comment()
    {
      begin("Comment","Comment");
      if (!next("//")) return reject();
      if (EOL()) return reject();
      do if (!next()) return reject();
        while (!EOL());
      return accept();
    }
  
  //=====================================================================
  //  BlockComment = "/*" _*+ "*/" <Comment> ;
  //=====================================================================
  private boolean BlockComment()
    {
      begin("BlockComment","Comment");
      if (!next("/*")) return reject();
      while (!next("*/"))
        if (!next()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  EOL = "\n" / EOT <EOL> ;
  //=====================================================================
  private boolean EOL()
    {
      begin("EOL","EOL");
      if (next('\n')) return accept();
      if (EOT()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  EOT = !_ ;
  //=====================================================================
  private boolean EOT()
    {
      begin("EOT");
      if (!aheadNot()) return reject();
      return accept();
    }
  
}
