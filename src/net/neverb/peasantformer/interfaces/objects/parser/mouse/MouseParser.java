//=========================================================================
//
//  This file was generated by Mouse 1.4 at 2011-10-26 13:02:49 GMT
//  from grammar
//    '/home/user/soft/java/idea/PeasantFormer/src/net/neverb/peasantformer
//    /interfaces/objects/parser/mouse/MouseRules.txt'.
//
//=========================================================================

package net.neverb.peasantformer.interfaces.objects.parser.mouse;

import mouse.runtime.Source;

public class MouseParser extends mouse.runtime.ParserBase
{
  final MouseParserSymantics sem;
  
  //=======================================================================
  //
  //  Initialization
  //
  //=======================================================================
  //-------------------------------------------------------------------
  //  Constructor
  //-------------------------------------------------------------------
  public MouseParser()
    {
      sem = new MouseParserSymantics();
      sem.rule = this;
      super.sem = sem;
    }
  
  //-------------------------------------------------------------------
  //  Run the parser
  //-------------------------------------------------------------------
  public boolean parse(Source src)
    {
      super.init(src);
      sem.init();
      if (Config()) return true;
      return failure();
    }
  
  //-------------------------------------------------------------------
  //  Get semantics
  //-------------------------------------------------------------------
  public MouseParserSymantics semantics()
    { return sem; }
  
  //=======================================================================
  //
  //  Parsing procedures
  //
  //=======================================================================
  //=====================================================================
  //  Config = Space Group EOT {config} ;
  //=====================================================================
  private boolean Config()
    {
      begin("Config");
      Space();
      if (!Group()) return reject();
      if (!EOT()) return reject();
      sem.config();
      return accept();
    }
  
  //=====================================================================
  //  Group = Literal Lcurly PropertyList Rcurly {group} ;
  //=====================================================================
  private boolean Group()
    {
      begin("Group");
      if (!Literal()) return reject();
      if (!Lcurly()) return reject();
      PropertyList();
      if (!Rcurly()) return reject();
      sem.group();
      return accept();
    }
  
  //=====================================================================
  //  PropertyList = (Property / Group)* {propertylist} ;
  //=====================================================================
  private boolean PropertyList()
    {
      begin("PropertyList");
      while (PropertyList_0());
      sem.propertylist();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  PropertyList_0 = Property / Group
  //-------------------------------------------------------------------
  private boolean PropertyList_0()
    {
      begin("");
      if (Property()) return acceptInner();
      if (Group()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  Property = Literal Equals (Number / QuotedString / Point /
  //    Point2DArray) Space SemiColon {property} ;
  //=====================================================================
  private boolean Property()
    {
      begin("Property");
      if (!Literal()) return reject();
      if (!Equals()) return reject();
      if (!Number()
       && !QuotedString()
       && !Point()
       && !Point2DArray()
         ) return reject();
      Space();
      if (!SemiColon()) return reject();
      sem.property();
      return accept();
    }
  
  //=====================================================================
  //  Lcurly = "{" Space ;
  //=====================================================================
  private boolean Lcurly()
    {
      begin("Lcurly");
      if (!next('{')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  Rcurly = "}" Space ;
  //=====================================================================
  private boolean Rcurly()
    {
      begin("Rcurly");
      if (!next('}')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  Equals = "=" Space ;
  //=====================================================================
  private boolean Equals()
    {
      begin("Equals");
      if (!next('=')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  SemiColon = ";" Space ;
  //=====================================================================
  private boolean SemiColon()
    {
      begin("SemiColon");
      if (!next(';')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  PointNDArray = Lbracket PointNDElem (Comma PointNDElem)* Rbracket
  //    ;
  //=====================================================================
  private boolean PointNDArray()
    {
      begin("PointNDArray");
      if (!Lbracket()) return reject();
      if (!PointNDElem()) return reject();
      while (PointNDArray_0());
      if (!Rbracket()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  PointNDArray_0 = Comma PointNDElem
  //-------------------------------------------------------------------
  private boolean PointNDArray_0()
    {
      begin("");
      if (!Comma()) return rejectInner();
      if (!PointNDElem()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  PointNDElem = PointNDArray / Point ;
  //=====================================================================
  private boolean PointNDElem()
    {
      begin("PointNDElem");
      if (PointNDArray()) return accept();
      if (Point()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Point2DArray = Lbracket PointArray (Comma PointArray)* Rbracket
  //    {point2d} ;
  //=====================================================================
  private boolean Point2DArray()
    {
      begin("Point2DArray");
      if (!Lbracket()) return reject();
      if (!PointArray()) return reject();
      while (Point2DArray_0());
      if (!Rbracket()) return reject();
      sem.point2d();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Point2DArray_0 = Comma PointArray
  //-------------------------------------------------------------------
  private boolean Point2DArray_0()
    {
      begin("");
      if (!Comma()) return rejectInner();
      if (!PointArray()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  PointArray = Lbracket Point (Comma Point)* Rbracket {point1d} ;
  //=====================================================================
  private boolean PointArray()
    {
      begin("PointArray");
      if (!Lbracket()) return reject();
      if (!Point()) return reject();
      while (PointArray_0());
      if (!Rbracket()) return reject();
      sem.point1d();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  PointArray_0 = Comma Point
  //-------------------------------------------------------------------
  private boolean PointArray_0()
    {
      begin("");
      if (!Comma()) return rejectInner();
      if (!Point()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Point = Lbracket Number Comma Number Rbracket {point} ;
  //=====================================================================
  private boolean Point()
    {
      begin("Point");
      if (!Lbracket()) return reject();
      if (!Number()) return reject();
      if (!Comma()) return reject();
      if (!Number()) return reject();
      if (!Rbracket()) return reject();
      sem.point();
      return accept();
    }
  
  //=====================================================================
  //  Lbracket = "[" Space ;
  //=====================================================================
  private boolean Lbracket()
    {
      begin("Lbracket");
      if (!next('[')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  Comma = "," Space ;
  //=====================================================================
  private boolean Comma()
    {
      begin("Comma");
      if (!next(',')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  Rbracket = "]" Space ;
  //=====================================================================
  private boolean Rbracket()
    {
      begin("Rbracket");
      if (!next(']')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  Number = NumberRules Space {number} ;
  //=====================================================================
  private boolean Number()
    {
      begin("Number");
      if (!NumberRules()) return reject();
      Space();
      sem.number();
      return accept();
    }
  
  //=====================================================================
  //  NumberRules = "-"? Digit+ ("." Digit+)? [fmpr]? ;
  //=====================================================================
  private boolean NumberRules()
    {
      begin("NumberRules");
      next('-');
      if (!Digit()) return reject();
      while (Digit());
      NumberRules_0();
      nextIn("fmpr");
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  NumberRules_0 = "." Digit+
  //-------------------------------------------------------------------
  private boolean NumberRules_0()
    {
      begin("");
      if (!next('.')) return rejectInner();
      if (!Digit()) return rejectInner();
      while (Digit());
      return acceptInner();
    }
  
  //=====================================================================
  //  QuotedString = """ UnquotedString """ Space {string} ;
  //=====================================================================
  private boolean QuotedString()
    {
      begin("QuotedString");
      if (!next('"')) return reject();
      UnquotedString();
      if (!next('"')) return reject();
      Space();
      sem.string();
      return accept();
    }
  
  //=====================================================================
  //  UnquotedString = Characters ("\"" Characters)* ;
  //=====================================================================
  private boolean UnquotedString()
    {
      begin("UnquotedString");
      Characters();
      while (UnquotedString_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  UnquotedString_0 = "\"" Characters
  //-------------------------------------------------------------------
  private boolean UnquotedString_0()
    {
      begin("");
      if (!next("\\\"")) return rejectInner();
      Characters();
      return acceptInner();
    }
  
  //=====================================================================
  //  Characters = ^["\]* ;
  //=====================================================================
  private boolean Characters()
    {
      begin("Characters");
      while (nextOut("\"\\"));
      return accept();
    }
  
  //=====================================================================
  //  Literal = LiteralFirst LiteralRest* Space ;
  //=====================================================================
  private boolean Literal()
    {
      begin("Literal");
      if (!LiteralFirst()) return reject();
      while (LiteralRest());
      Space();
      return accept();
    }
  
  //=====================================================================
  //  LiteralRest = Letter / Digit / Separators ;
  //=====================================================================
  private boolean LiteralRest()
    {
      begin("LiteralRest");
      if (Letter()) return accept();
      if (Digit()) return accept();
      if (Separators()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  LiteralFirst = Letter ;
  //=====================================================================
  private boolean LiteralFirst()
    {
      begin("LiteralFirst");
      if (!Letter()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Separators = [-_] ;
  //=====================================================================
  private boolean Separators()
    {
      begin("Separators");
      if (!nextIn("-_")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Digit = [0-9] ;
  //=====================================================================
  private boolean Digit()
    {
      begin("Digit");
      if (!nextIn('0','9')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Letter = [a-z] / [A-Z] ;
  //=====================================================================
  private boolean Letter()
    {
      begin("Letter");
      if (nextIn('a','z')) return accept();
      if (nextIn('A','Z')) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Space = ([ \r\n\t] / Comment)* ;
  //=====================================================================
  private boolean Space()
    {
      begin("Space");
      while (Space_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Space_0 = [ \r\n\t] / Comment
  //-------------------------------------------------------------------
  private boolean Space_0()
    {
      begin("");
      if (nextIn(" \r\n\t")) return acceptInner();
      if (Comment()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  Comment = ("//" / "#") _++ EOL ;
  //=====================================================================
  private boolean Comment()
    {
      begin("Comment");
      if (!next("//")
       && !next('#')
         ) return reject();
      if (EOL()) return reject();
      do if (!next()) return reject();
        while (!EOL());
      return accept();
    }
  
  //=====================================================================
  //  EOL = "\n" / EOT ;
  //=====================================================================
  private boolean EOL()
    {
      begin("EOL");
      if (next('\n')) return accept();
      if (EOT()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  EOT = !_ ;
  //=====================================================================
  private boolean EOT()
    {
      begin("EOT");
      if (!aheadNot()) return reject();
      return accept();
    }
  
}
